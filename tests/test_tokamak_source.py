from openmc_plasma_source import TokamakSource
from openmc import Source
import numpy as np

import pytest
from hypothesis import given, settings, assume, strategies as st


@pytest.fixture(scope="module")
def tokamak_plasma_input():
    """Defines a fixed set of plasma inputs, known to be valid."""
    return {
        "ion_density_centre": 1.09e20,
        "ion_density_peaking_factor": 1,
        "ion_density_pedestal": 1.09e20,
        "ion_density_separatrix": 3e19,
        "ion_temperature_centre": 45.9,
        "ion_temperature_peaking_factor": 8.06,
        "ion_temperature_pedestal": 6.09,
        "ion_temperature_separatrix": 0.1,
        "mode": "H",
        "ion_temperature_beta": 6,
    }


@pytest.fixture(scope="module")
def tokamak_geometry_input():
    """Defines a fixed set of tokamak geometry inputs, known to be valid."""
    return {
        "elongation": 1.557,
        "triangularity": 0.270,
        "major_radius": 9.06,
        "minor_radius": 2.92258,
        "pedestal_radius": 0.8 * 2.92258,
        "shafranov_factor": 0.44789,
    }


@pytest.fixture(scope="module")
def tokamak_input(tokamak_plasma_input, tokamak_geometry_input):
    """ Combines the plasma input and geometry input fixtures for convenience."""
    return {**tokamak_plasma_input, **tokamak_geometry_input}


@pytest.fixture(scope="function")
def tokamak_source(tokamak_input):
    """Creates example of a TokamakSource with inputs known to be valid. 
    Note that this fixture is rebuilt for each function call.
    """
    return TokamakSource(**tokamak_input)


@st.composite
def tokamak_geometry_strategy(draw):
    """Defines a hypothesis strategy that automatically generates dictionaries of
    tokamak geometry inputs.
    """
    # Used to avoid generation of inappropriate float values
    finites = {"allow_nan": False, "allow_infinity": False, "allow_subnormal": False}

    # Specify the base strategies for each geometry input
    minor_radius = draw(st.floats(min_value=0.0, max_value=100.0, **finites))
    major_radius = draw(st.floats(min_value=0.0, max_value=100.0, **finites))
    pedestal_radius = draw(st.floats(min_value=0.0, max_value=100.0, **finites))
    elongation = draw(st.floats(min_value=1.0, max_value=10.0, **finites))
    triangularity = draw(st.floats(min_value=0.0, max_value=1.0, **finites))
    shafranov_factor = draw(st.floats(min_value=0.0, max_value=1.0, **finites))

    # Specify requirements that must be satisfied for a valid tokamak
    assume(major_radius > minor_radius)
    assume(minor_radius > pedestal_radius)
    assume(minor_radius > shafranov_factor)

    return {
        "elongation": elongation,
        "triangularity": triangularity,
        "major_radius": major_radius,
        "minor_radius": minor_radius,
        "pedestal_radius": pedestal_radius,
        "shafranov_factor": shafranov_factor,
    }


def test_creation(tokamak_source):
    """Tests that the sources generated by TokamakSource are of type openmc.Source"""
    for source in tokamak_source.sources:
        assert isinstance(source, Source)


def test_strengths_are_normalised(tokamak_source):
    """Tests that the sum of the strengths attribute is equal to"""
    assert pytest.approx(sum(tokamak_source.strengths), 1)


@given(geometry=tokamak_geometry_strategy())
@settings(max_examples=100, deadline=None)
def test_source_locations_are_within_correct_range(geometry, tokamak_plasma_input):
    """Tests that each source has RZ locations within the expected range.
    As the function converting (a,alpha) coordinates to (R,Z) is not bijective, we
    cannot convert back to validate each individual point. However, we can determine
    whether the generated points are contained within the shell of the last closed
    magnetic surface.
    See "Tokamak D-T neutron source models for different plasma physics confinement
    modes", C. Fausser et al., Fusion Engineering and Design, 2012 for more info.
    """
    tokamak_source = TokamakSource(**geometry, **tokamak_plasma_input)
    R_0 = geometry["major_radius"]
    A = geometry["minor_radius"]
    El = geometry["elongation"]
    delta = geometry["triangularity"]

    def get_R_on_LCMS(alpha):
        """Gets R on the last closed magnetic surface for a given alpha"""
        return R_0 + A * np.cos(alpha + delta * np.sin(alpha))

    for source in tokamak_source.sources:
        R, Z = source.space.r.x[0], source.space.z.x[0]
        # First test that the point is contained with a simple box with
        # lower left (r_min,-z_max) and upper right (r_max,z_max)
        assert R > R_0 - A or np.isclose(R, R_0 - A)
        assert R < R_0 + A or np.isclose(R, R_0 + A)
        assert abs(Z) < A * El or np.isclose(abs(Z), A * El)
        # For a given Z, we can determine the two values of alpha where
        # where a = minor_radius, and from there determine the upper and
        # lower bounds for R.
        alpha_1 = np.arcsin(abs(Z) / (El * A))
        alpha_2 = np.pi - alpha_1
        R_max, R_min = get_R_on_LCMS(alpha_1), get_R_on_LCMS(alpha_2)
        assert R_max < R_0 + A or np.isclose(R_max, R_0 + A)
        assert R_min > R_0 - A or np.isclose(R_min, R_0 - A)
        assert R < R_max or np.isclose(R, R_max)
        assert R > R_min or np.isclose(R, R_min)


def test_angles(tokamak_input):
    """Checks that custom angles can be set"""
    alt_input = tokamak_input.copy()
    alt_input["angles"] = (0, 1)
    alt_source = TokamakSource(**alt_input)
    assert alt_source.angles == (0, 1)
    for source in alt_source.sources:
        assert (source.space.phi.a, source.space.phi.b) == (0, 1)
